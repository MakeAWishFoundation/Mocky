
#if Mocky
import Mocky
import XCTest
<%_ if let imported = arguments["import"] as? String { -%>
<%_ %>import <%= imported %>
<%_ } -%>
<%_ if let allimported = arguments["import"] as? [String] { -%>
<%_ for imported in allimported { %>
<%_ %>import <%= imported -%>
<%_ } -%>
<%_ } -%>
<% %>
<%_ if let tested = arguments["testable"] as? String { -%>
<%_ %>@testable import <%= tested %>
<%_ } -%>
<%_ if let alltested = arguments["testable"] as? [String] { -%>
<%_ for tested in alltested { -%>
<%_ %>@testable import <%= tested %>
<%_ } -%>
<%_ } -%>
<% %>
#else
import Sourcery
import SourceryRuntime
#endif

<%_ if let rules = arguments["excludedSwiftLintRules"] as? [String] { -%>
<%_ for rule in rules { -%>
<%_ %>//swiftlint:disable <%= rule %> 
<%_ } -%>
<%_ } -%>

<%# Helper methods -%>
<%
func uniques(methods: [SourceryRuntime.Method]) -> [SourceryRuntime.Method] {
    return methods.reduce([], { (result, element) -> [SourceryRuntime.Method] in
        guard !result.contains(where: { $0.name == element.name }) else { return result }
        return result + [element]
    })
}

func uniques(variables: [SourceryRuntime.Variable]) -> [SourceryRuntime.Variable] {
    return variables.reduce([], { (result, element) -> [SourceryRuntime.Variable] in
        guard !result.contains(where: { $0.name == element.name }) else { return result }
        return result + [element]
    })
}

class ParameterWrapper {
    let parameter: MethodParameter
    init(_ parameter: SourceryRuntime.MethodParameter) {
        self.parameter = parameter
    }

    var wrappedType: String {
        get {
            return "Parameter<\(parameter.typeName.name)>"
        }
    }

    var comparator: String {
        get {
            return "guard Parameter.compare(lhs: lhs\(parameter.name.capitalized), rhs: rhs\(parameter.name.capitalized), with: matcher) else { return false }"
        }
    }
}

class VariableWrapper {
    let variable: SourceryRuntime.Variable
    let scope: String

    var privatePrototypeName: String { return "__\(variable.name)" }

    var getter: String {
        return "get { return \(variable.isStatic ? "\(scope)." : "")\(privatePrototypeName) }"
    }
    var setter: String {
        return "set { \(variable.isStatic ? "\(scope)." : "")\(privatePrototypeName) = newValue }"
    }
    var prototype: String {
        let staticModifier = variable.isStatic ? "static " : ""

        return "\(staticModifier)var \(variable.name): \(variable.typeName.name) { \n" +
        "\t\t\(getter)\n" +
        "\t\t\(setter)\n" +
        "\t}"
    }

    var privatePrototype: String {
        let staticModifier = variable.isStatic ? "static " : ""
        let type: String = {
          if variable.isOptional || variable.isImplicitlyUnwrappedOptional {
              return "\(variable.typeName.name)"
          } else {
              return "\(variable.typeName.unwrappedTypeName)!"
          }
        }()
        return "private \(staticModifier)var \(privatePrototypeName): \(type)"
    }

    init(_ variable: SourceryRuntime.Variable, scope: String) {
        self.variable = variable
        self.scope = scope
    }

}

class MethodWrapper {
    private static var registered: [String: Int] = [:]
    private static var suffixes: [String: Int] = [:]

    let method: SourceryRuntime.Method

    private var registrationName: String {
        get {
            var rawName = method.selectorName
                .replacingOccurrences(of: "_", with: "")
                .replacingOccurrences(of: "(", with: "__")
                .replacingOccurrences(of: ")", with: "")

            var parametersNames = method.parameters.map { "\($0.name)" }

            while let range = rawName.range(of: ":"), let name = parametersNames.first {
                parametersNames.removeFirst()
                rawName.replaceSubrange(range, with: "_\(name)")
            }

            return rawName
                .replacingOccurrences(of: "___", with: "__")
                .trimmingCharacters(in: CharacterSet(charactersIn: "_"))
        }
    }
    private var uniqueName: String {
        get {
            var rawName = method.selectorName
            var parametersNames = method.parameters.map { "\($0.name)_of_\($0.typeName.name)" }

            while let range = rawName.range(of: ":"), let name = parametersNames.first {
                parametersNames.removeFirst()
                rawName.replaceSubrange(range, with: "_\(name)")
            }

            return rawName
                .trimmingCharacters(in: CharacterSet(charactersIn: "_"))
        }
    }
    private var nameSuffix: String {
        guard let count = MethodWrapper.registered[registrationName] else { return "" }
        guard count > 1 else { return "" }

        guard let index = MethodWrapper.suffixes[uniqueName] else { return "" }
        return "_\(index)"
    }

    var prototype: String {
        get {
          return "\(registrationName)\(nameSuffix)"
        }
    }
    var parameters: [ParameterWrapper] {
        get {
            return method.parameters.map { ParameterWrapper($0) }
        }
    }
    var functionPrototype: String {
        get {
            if method.returnTypeName.isVoid {
                return "func \(method.name) "
            } else {
                return "func \(method.name) -> \(method.returnTypeName.name) "
            }
        }
    }
    var invocation: String {
        if method.parameters.isEmpty {
            return "addInvocation(.\(prototype))"
        } else {
            let parameters = method.parameters.map { ".value(\($0.name))" }.joined(separator: ", ")
            return "addInvocation(.\(prototype)(\(parameters)))"
        }
    }
    var returnValue: String {
        guard !method.returnTypeName.isVoid else { return "" }
        if method.parameters.isEmpty {
            return "return methodReturnValue(.\(prototype)) as! \(method.returnTypeName) "
        } else {
            let parameters = method.parameters.map { ".value(\($0.name))" }.joined(separator: ", ")
            return "return methodReturnValue(.\(prototype)(\(parameters))) as! \(method.returnTypeName) "
        }
    }
    var equalCase: String {
        get {
            if method.parameters.isEmpty {
                return "case (.\(prototype), .\(prototype)):"
            } else {
                let lhsParams = method.parameters.map { "let lhs\($0.name.capitalized)" }.joined(separator: ", ")
                let rhsParams = method.parameters.map { "let rhs\($0.name.capitalized)" }.joined(separator: ", ")
                return "case (.\(prototype)(\(lhsParams)), .\(prototype)(\(rhsParams))):"
            }
        }
    }
    var intValueCase: String {
        get {
            if method.parameters.isEmpty {
                return "case .\(prototype): return 0"
            } else {
                let params = method.parameters.enumerated().map { offset, _ in
                    return "p\(offset)"
                }
                let definitions = params.joined(separator: ", ")
                let paramsSum = params.map({ "\($0).intValue" }).joined(separator: " + ")
                return "case let .\(prototype)(\(definitions)): return \(paramsSum)"
            }
        }
    }

    init(_ method: SourceryRuntime.Method) {
        self.method = method
    }

    static func clear() -> String {
        MethodWrapper.registered = [:]
        MethodWrapper.suffixes = [:]
        return ""
    }

    func register() -> String {
        let name = registrationName
        if let count = MethodWrapper.registered[name] {
            MethodWrapper.registered[name] = count + 1
            MethodWrapper.suffixes[uniqueName] = count + 1
            // print("registered \(name) with \(count + 1)")
        } else {
            MethodWrapper.registered[name] = 1
            MethodWrapper.suffixes[uniqueName] = 1
            // print("registered \(name) with \(1)")
        }

        return ""
    }

    func methodDeclarationWithParameters() -> String {
        if method.parameters.isEmpty {
            return method.shortName
        }
        let parameters = method.parameters
        .map {  return "Parameter<\($0.typeName.name)>" }
        .joined(separator: ", ")
        .replacingOccurrences(of: "@escaping", with: "")
        return "\(prototype)(\(parameters))"
    }

    func proxyConstructor() -> String {
        if method.parameters.isEmpty {
            return "return MethodProxy(method: .\(prototype), returns: willReturn)"
        } else {
            let parameters = method.parameters.map { "\($0.name)" }.joined(separator: ", ")
            return "return MethodProxy(method: .\(prototype)(\(parameters)), returns: willReturn)"
        }
    }

    func proxyConstructorName() -> String {
        if method.parameters.isEmpty {
            return "static func \(method.shortName)(willReturn: \(method.returnTypeName)) -> MethodProxy"
        } else {
            let functionParameters = method.parameters.map {
                guard let argumentLabel = $0.argumentLabel else {
                    return "\($0.name): Parameter<\($0.typeName)>"
                }

                return "\(argumentLabel) \($0.name): Parameter<\($0.typeName)>"
            }.joined(separator: ", ")
            return "static func \(method.shortName)(\(functionParameters), willReturn: \(method.returnTypeName)) -> MethodProxy"
        }
    }

    func verificationProxyConstructorName() -> String {
        if method.parameters.isEmpty {
            return "static func \(method.shortName)() -> VerificationProxy"
        } else {
            let functionParameters = method.parameters.map {
                guard let argumentLabel = $0.argumentLabel else {
                    return "\($0.name): Parameter<\($0.typeName)>"
                }

                return "\(argumentLabel) \($0.name): Parameter<\($0.typeName)>"
            }.joined(separator: ", ")
            return "static func \(method.shortName)(\(functionParameters)) -> VerificationProxy"
        }
    }

    func verificationProxyConstructor() -> String {
        if method.parameters.isEmpty {
            return "return VerificationProxy(method: .\(prototype))"
        } else {
            let parameters = method.parameters.map { "\($0.name)" }.joined(separator: ", ")
            return "return VerificationProxy(method: .\(prototype)(\(parameters)))"
        }
    }
}

func wrapMethod(_ method: SourceryRuntime.Method) -> MethodWrapper {
    return MethodWrapper(method)
}

-%>

<%# implement variable for Optional types and IUO, for other add marker that you need to implement those yourself in non-genreated code scope-%>
<%# TODO: make examples for all types of properties with different kinds of accesors-%>
<%
func stubProperty(_ variable: SourceryRuntime.Variable, _ scope: String) -> String {
    let wrapper = VariableWrapper(variable, scope: scope)
    return "\(wrapper.prototype)\n\t\(wrapper.privatePrototype)"
}
-%>

<%# Mock.generated -%>
<% for type in types.protocols {
    guard type.inheritedTypes.contains("AutoMockable") || type.annotations["AutoMockable"] != nil else { continue }
    let aProtocol = type
     -%>
<%_ %>// MARK: - <%= type.name %>
class <%= type.name %>Mock: <%= type.name %>, Mock {

      var invocations: [MethodType] = []
      var methodReturnValues: [MethodProxy] = []
      var matcher: Matcher = Matcher.default
      <%_ -%>
      <% let allVariables = uniques(variables: aProtocol.allVariables) %><%_ -%>
      <% let allMethods = uniques(methods: aProtocol.allMethods) %><%_ -%>

      <%_ for variable in allVariables { %>
      <%= stubProperty(variable,"\(type.name)Mock") -%>
      <% } %> <%_ -%>
      <%_ -%>
      <% MethodWrapper.clear() -%>
      <% for method in allMethods.map(wrapMethod) { method.register() } -%>

      <%_ for method in allMethods.map(wrapMethod) { %>
      <%= method.functionPrototype _%> {
          <%= method.invocation _%>
          <%= method.returnValue _%>
      }
      <%  } %> <%_ -%>

      enum MethodType {
      <%_ for method in allMethods.map(wrapMethod) { _%>
          case <%= method.methodDeclarationWithParameters() -%>
      <%  } %>
      <%_ %>
          static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
              switch (lhs, rhs) { <%_ for method in allMethods.map(wrapMethod) { %>
                  <%= method.equalCase -%> <% for parameter in method.parameters { %>
                      <%= parameter.comparator -%> <%  } %>
                      return true <% } %>
                  <%_ -%>
                  default: return false
              }
          }
      <%_ %>
          func intValue() -> Int {
              switch self { <%_ for method in allMethods.map(wrapMethod) { %>
                  <%= method.intValueCase -%><% } %>
              }
          }
      }

      struct MethodProxy {
          var method: MethodType
          var returns: Any?
          <%_ for method in allMethods.filter({ !$0.returnTypeName.isVoid }).map(wrapMethod) { %>
          <%= method.proxyConstructorName() -%> {
              <%= method.proxyConstructor() _%>
          }
  <%  } %> <%_ -%>
      }

      struct VerificationProxy {
          var method: MethodType

          <%_ for method in allMethods.map(wrapMethod) { %>
          <%= method.verificationProxyConstructorName() -%> {
              <%= method.verificationProxyConstructor() _%>
          }
  <%  } %> <%_ -%>
      }

      public func methodReturnValue(_ method: MethodType) -> Any? {
          let matched = methodReturnValues.reversed().first(where: { proxy -> Bool in
              return MethodType.compareParameters(lhs: proxy.method, rhs: method, matcher: matcher)
          })

          return matched?.returns
      }

      public func verify(_ method: VerificationProxy, count: UInt = 1, file: StaticString = #file, line: UInt = #line) {
          let method = method.method
          let invocations = matchingCalls(method)
          XCTAssert(invocations.count == Int(count), "Expeced: \(count) invocations of `\(method)`, but was: \(invocations.count)", file: file, line: line)
      }

      public func addInvocation(_ call: MethodType) {
          invocations.append(call)
      }

      public func matchingCalls(_ method: MethodType) -> [MethodType] {
          let matchingInvocations = invocations.filter({ (call) -> Bool in
              return MethodType.compareParameters(lhs: call, rhs: method, matcher: matcher)
          })
          return matchingInvocations
      }

      public func matchingCalls(_ method: VerificationProxy) -> [MethodType] {
          return matchingCalls(method.method)
      }

      public func given(_ method: MethodProxy) {
          methodReturnValues.append(method)
          methodReturnValues.sort { $0.method.intValue() < $1.method.intValue() }
      }
}

<% } -%>

<%# Inline annotations -%>
<% for type in types.all {
    guard let protocolToDecorate = type.annotations["mock"] as? String else { continue }
    if let aProtocol = types.protocols.first(where: { $0.name == protocolToDecorate }) { -%>
    // sourcery:inline:auto:<%= type.name %>.autoMocked
    <%_ if let rules = arguments["excludedSwiftLintRules"] as? [String] { -%>
    <%_ for rule in rules { -%>
    <%_ %>//swiftlint:disable <%= rule %> 
    <%_ } -%>
    <%_ } -%>

    var invocations: [MethodType] = []
    var methodReturnValues: [MethodProxy] = []
    var matcher: Matcher = Matcher.default
    <%_ -%>
    <% let allVariables = uniques(variables: aProtocol.allVariables) %><%_ -%>
    <% let allMethods = uniques(methods: aProtocol.allMethods) %><%_ -%>

    //MARK : <%= aProtocol.name %>
    <%_ for variable in allVariables { %>
    <%= stubProperty(variable,type.name) -%>
    <% } %> <%_ -%>
    <%_ -%>
    <% MethodWrapper.clear() -%>
    <% for method in allMethods.map(wrapMethod) { method.register() } -%>

    <%_ for method in allMethods.map(wrapMethod) { %>
    <%= method.functionPrototype _%> {
        <%= method.invocation _%>
        <%= method.returnValue _%>
    }
    <%  } %> <%_ -%>

    enum MethodType {
    <%_ for method in allMethods.map(wrapMethod) { _%>
        case <%= method.methodDeclarationWithParameters() -%>
    <%  } %>
    <%_ -%>
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
             <%_ for method in allMethods.map(wrapMethod) { %>
                <%= method.equalCase -%> <% for parameter in method.parameters { %>
                    <%= parameter.comparator -%> <%  } %>
                    return true <% } %>
                <%_ -%>
                default: return false
            }
        }
    <%_ %>
        func intValue() -> Int {
            switch self { <%_ for method in allMethods.map(wrapMethod) { %>
                <%= method.intValueCase -%><% } %>
            }
        }
    }

    struct MethodProxy {
        var method: MethodType
        var returns: Any?
        <%_ for method in allMethods.filter({ !$0.returnTypeName.isVoid }).map(wrapMethod) { %>
        <%= method.proxyConstructorName() -%> {
            <%= method.proxyConstructor() _%>
        }
<%  } %> <%_ -%>
    }

    struct VerificationProxy {
        var method: MethodType

        <%_ for method in allMethods.map(wrapMethod) { %>
        <%= method.verificationProxyConstructorName() -%> {
            <%= method.verificationProxyConstructor() _%>
        }
<%  } %> <%_ -%>
    }

    public func methodReturnValue(_ method: MethodType) -> Any? {
        let matched = methodReturnValues.reversed().first(where: { proxy -> Bool in
            return MethodType.compareParameters(lhs: proxy.method, rhs: method, matcher: matcher)
        })

        return matched?.returns
    }

    public func verify(_ method: VerificationProxy, count: UInt = 1, file: StaticString = #file, line: UInt = #line) {
        let method = method.method
        let invocations = matchingCalls(method)
        XCTAssert(invocations.count == Int(count), "Expeced: \(count) invocations of `\(method)`, but was: \(invocations.count)", file: file, line: line)
    }

    public func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }

    public func matchingCalls(_ method: MethodType) -> [MethodType] {
        let matchingInvocations = invocations.filter({ (call) -> Bool in
            return MethodType.compareParameters(lhs: call, rhs: method, matcher: matcher)
        })
        return matchingInvocations
    }

    public func matchingCalls(_ method: VerificationProxy) -> [MethodType] {
        return matchingCalls(method.method)
    }

    public func given(_ method: MethodProxy) {
        methodReturnValues.append(method)
        methodReturnValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

// sourcery:end
<% }
} -%>
